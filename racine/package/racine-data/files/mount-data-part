#!/bin/sh

# Auto expand /dev/data partition
# Mount persited file systems

set -e

PATH=/usr/sbin:/usr/bin:/sbin:/bin

PARTITION="$(readlink -f /dev/disk/by-label/data)"

expand_data_part() {
    # Expand data partition to all the available space
    # Inspired from HassOS partition expander
    #

    device="/dev/$(lsblk -no pkname "${PARTITION}")"
    part_num="$(cat "/sys/class/block/$(basename "${PARTITION}")/partition")"

    # TODO: check is gpt
    # TODO: check is is last part

    if sfdisk --verify "${device}" 2>&1 | grep "The backup GPT table is not on the end of the device."; then
        echo "Moving GPT backup header to the end"
        sfdisk --relocate gpt-bak-std "${device}"
    fi

    # TODO: check free space
    disk_lastlba=$(sfdisk -d "${device}" | grep '^last-lba:' | awk '{print $2}')
    part_lastlba=$(sfdisk -lq "${device}" | grep "^${PARTITION}" | awk '{print $3}')
    free_space=$(echo "${disk_lastlba}-${part_lastlba}" | bc)

    echo "Disk last LBA = ${disk_lastlba} Partition last LBA = ${part_lastlba} Free space = ${free_space}"

    if [ "${free_space}" -le "16384" ]; then
        echo "No resize of data partition needed"
        return 0
    fi

    echo "Expanding data partition (${PARTITION})"
    echo ", +" | sfdisk --no-reread --no-tell-kernel -N "${part_num}" "${device}"
    sfdisk --verify "${device}"

    # Update the kernel's partition table
    partx -u "${device}"
    udevadm settle

    resize2fs "${PARTITION}"
}

create_file() {
    file="$1"
    src="$2"

    mkdir -p "$(dirname "${file}")"

    if [ -n "${src}" ]; then
        cp -a "${src}" "${file}"
    else
        touch "${file}"
    fi
}

create_dir() {
    file="$1"
    src="$2"

    mkdir -p "${file}"

    if [ -n "${src}" ]; then
        cp -a "${src}/." "${file}"
    fi
}

expand_data_part

mount "${PARTITION}" /data

for fs in $(cat /etc/persist.list); do
    datafs="/data/${fs}"
    last="${fs: -1}"
    if [ ! -e "${datafs}" ]; then
        # create the file to mount
        if [ -d "${fs}" ]; then
            create_dir "${datafs}" "${fs}"
        elif [ -f "${fs}" ]; then
            create_file "${datafs}" "${fs}"
        elif [ "$last" = / ]; then
            create_dir "${datafs}"
        else
            create_file "${datafs}"
        fi
    fi
    if [ ! -e "${fs}" ]; then
        # try creating the mount point
        # expect it to fail in most cases as rootfs is R/O
        if [ "$last" = / ]; then
            create_dir "${fs}" || true
        else
            create_file "${fs}" || true
        fi
    fi
    if [ -e "${fs}" ]; then
        mount --bind "${datafs}" "${fs}"
    else
        echo "Could not mount on ${fs} as it does not exist and we could not create it"
    fi
done
